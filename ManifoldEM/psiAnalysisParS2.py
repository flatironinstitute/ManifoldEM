import numpy as np

from ManifoldEM import NLSA, myio, p
'''
Copyright (c) UWM, Ali Dashti 2016 (original matlab version)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
CCopyright (c) Columbia University Hstau Liao 2018 (python version)
Copyright (c) Columbia University Evan Seitz 2019 (python version)
Copyright (c) Columbia University Suvrajit Maji 2020 (python version)
'''


def corr(a, b, n, m):
    A = a[:, n]
    B = b[:, m]
    A = A - np.mean(A)
    B = B - np.mean(B)
    try:
        co = np.dot(A, B) / (np.std(A) * np.std(B))
    except RuntimeError:
        raise RuntimeError("flat image")
    return co


def diff_corr(a, b, maxval):
    return corr(a, b, 0, 0) + corr(a, b, maxval, maxval) - \
        (corr(a, b, 0, maxval) + corr(a, b, maxval, 0))


def op(input_data, con_order_range, traj_name, is_full, psi_trunc):
    dist_file = input_data[0]
    psi_file = input_data[1]  # 15-dim diffusion map coordinates
    psi2_file = input_data[2]  # output to be generated by Psi Analysis
    EL_file = input_data[3]
    psinums = input_data[4]
    senses = input_data[5]
    prD = input_data[6]
    if len(input_data) == 8:
        psi_list = input_data[7]
    else:
        psi_list = psinums
    data_IMG = myio.fin1(dist_file)
    data_psi = myio.fin1(psi_file)

    D = np.array(data_IMG['D'])  # distance matrix
    imgAll = np.array(data_IMG['imgAll'])  # every image in PD (and dimensions): e.g., shape=(numPDs,boxSize,boxSize)

    msk2 = np.array(data_IMG['msk2'])  # April 2020, vol mask to be used after ctf has been applied

    CTF = np.array(data_IMG['CTF'])
    psi = data_psi['psi']  # coordinates of all images in 15-dim space from diffusion map: e.g., shape=(numPDs,15)
    pos_path = data_psi['posPath']  # indices of every image in PD: e.g., shape=(numPDs,); [0,1,2,...(numPDs-1)]
    nS = len(pos_path)  # number of images in PD
    con_order = nS // con_order_range
    # if ConOrder is large, noise-free 2D frames expected w/ small range of conformations, \
    # while losing snapshots at edges

    dim = int(np.sqrt(imgAll.size / D.shape[0]))
    CTF = CTF.reshape(D.shape[0], dim, dim)  # needed only if read from matlab
    pos_path = np.squeeze(pos_path)
    D = D[pos_path][:, pos_path]

    extra_params = dict(outDir='', prD=prD)
    for psinum in psi_list:  # for each reaction coordinates do the following:
        if psinum == -1:
            continue
        psi_sorted_ind = np.argsort(
            psi[:, psinum])  # e.g., shape=(numPDs,): reordering image indices along each diff map coord
        pos_psi1 = psi_sorted_ind  # duplicate of above...

        DD = D[pos_psi1]
        DD = DD[:, pos_psi1]  # distance matrix with indices of images re-arranged along current diffusion map coordinate
        num = DD.shape[1]  # number of images in PD (duplicate of nS?)
        k = num - con_order

        NLSAPar = dict(num=num, ConOrder=con_order, k=k, tune=p.tune, nS=nS, save=False, psiTrunc=psi_trunc)
        IMGT, Topo_mean, psirec, psiC1, sdiag, VX, mu, tau = NLSA.op(NLSAPar, DD, pos_path, pos_psi1, imgAll, msk2, CTF,
                                                                     extra_params)

        n_s_recon = min(IMGT.shape)
        numclass = min(p.nClass, n_s_recon // 2)

        tau = (tau - min(tau)) / (max(tau) - min(tau))
        tauinds = []
        i1 = 0
        i2 = IMGT.shape[0]

        IMG1 = np.zeros((i2, numclass), dtype='float64')
        for i in range(numclass):
            ind1 = float(i) / numclass
            ind2 = ind1 + 1. / numclass
            if (i == numclass - 1):
                tauind = ((tau >= ind1) & (tau <= ind2)).nonzero()[0]
            else:
                tauind = ((tau >= ind1) & (tau < ind2)).nonzero()[0]
            while (tauind.size == 0):
                sc = 1. / (numclass * 2.)
                ind1 = ind1 - sc * ind1
                ind2 = ind2 + sc * ind2
                tauind = ((tau >= ind1) & (tau < ind2)).nonzero()[0]

            IMG1[i1:i2, i] = IMGT[:, tauind[0]]
            tauinds.append(tauind[0])
        if is_full:  # second pass for EL1D
            #  adjust tau by comparing the IMG1s
            psi2_file = '{}_psi_{}'.format(psi2_file, psinum)
            data = myio.fin1(psi2_file)
            IMG1a = data['IMG1']

            dc = diff_corr(IMG1, IMG1a, numclass - 1)
            if (senses[0] == -1 and dc > 0) or senses[0] == 1 and dc < 0:
                tau = 1 - tau

            out_file = f'{EL_file}_{traj_name}_1'
            myio.fout1(out_file, IMG1=IMG1, IMGT=IMGT, posPath=pos_path, PosPsi1=pos_psi1, psirec=psirec,
                       tau=tau, psiC1=psiC1, mu=mu, VX=VX, sdiag=sdiag, Topo_mean=Topo_mean, tauinds=tauinds)

        else:  # first pass
            out_file = f'{psi2_file}_psi_{psinum}'
            myio.fout1(out_file, IMG1=IMG1, psirec=psirec, tau=tau, psiC1=psiC1, mu=mu, VX=VX, sdiag=sdiag,
                       Topo_mean=Topo_mean, tauinds=tauinds)
